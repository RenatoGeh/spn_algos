\documentclass{amsart}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{thmtools,thm-restate}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage[backend=biber,url=true,doi=true,eprint=false,style=alphabetic]{biblatex}
\usepackage{enumitem}
\usepackage[justification=centering,singlelinecheck=false]{caption}
\usepackage{indentfirst}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage[x11names, rgb]{xcolor}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{linegoal}
\usepackage{csquotes}
\usetikzlibrary{snakes,arrows,shapes}

\addbibresource{references.bib}

\makeatletter
\def\subsection{\@startsection{subsection}{3}%
  \z@{.5\linespacing\@plus.7\linespacing}{.1\linespacing}%
  {\normalfont}}
\makeatother

\makeatletter
\patchcmd{\@setauthors}{\MakeUppercase}{}{}{}
\makeatother

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\Val}{\text{Val}}
\DeclareMathOperator*{\Ch}{\text{Ch}}
\DeclareMathOperator*{\Pa}{\text{Pa}}
\DeclareMathOperator*{\Sc}{\text{Sc}}
\newcommand{\ov}{\overline}
\newcommand{\region}{\mathcal}

\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

\newcommand{\algorithmautorefname}{Algorithm}
\algrenewcommand\algorithmicrequire{\textbf{Input}}
\algrenewcommand\algorithmicensure{\textbf{Output}}
\algnewcommand{\LineComment}[1]{\State\,\(\triangleright\) #1}

\captionsetup[table]{labelsep=space}

\theoremstyle{plain}

\newcounter{dummy-def}\numberwithin{dummy-def}{section}
\newtheorem{definition}[dummy-def]{Definition}
\newcounter{dummy-thm}\numberwithin{dummy-thm}{section}
\newtheorem{theorem}[dummy-thm]{Theorem}
\newcounter{dummy-prop}\numberwithin{dummy-prop}{section}
\newtheorem{proposition}[dummy-prop]{Proposition}
\newcounter{dummy-corollary}\numberwithin{dummy-corollary}{section}
\newtheorem{corollary}[dummy-corollary]{Corollary}
\newcounter{dummy-lemma}\numberwithin{dummy-lemma}{section}
\newtheorem{lemma}[dummy-lemma]{Lemma}
\newcounter{dummy-ex}\numberwithin{dummy-ex}{section}
\newtheorem{exercise}[dummy-ex]{Exercise}
\newcounter{dummy-eg}\numberwithin{dummy-eg}{section}
\newtheorem{example}[dummy-eg]{Example}

\numberwithin{equation}{section}

\newcommand{\set}[1]{\mathbf{#1}}
\newcommand{\pr}{\mathbb{P}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\implies}{\Rightarrow}

\newcommand{\bigo}{\mathcal{O}}

\setlength{\parskip}{1em}

\lstset{frameround=fttt,
	numbers=left,
	breaklines=true,
	keywordstyle=\bfseries,
	basicstyle=\ttfamily,
}

\newcommand{\code}[1]{\lstinline[mathescape=true]{#1}}
\newcommand{\mcode}[1]{\lstinline[mathescape]!#1!}
\newcommand{\dset}[1]{\mathcal{#1}}

\title{%
  \noindent\rule{13cm}{1.0pt}\\
  \vspace{0.2cm}
  The Poon-Domingos Parameter Learning Algorithm for Image Completion and Classification on
  Sum-Product Networks
  \noindent\rule{13cm}{0.8pt}
}
\xdef\shorttitle{The Poon-Domingos Algorithm}
\author[]{\normalsize\textbf{Renato Lui Geh}\\\small Computer Science\\Institute of Mathematics
  and Statistics\\University of SÃ£o Paulo\\\texttt{renatolg@ime.usp.br}}

\begin{document}

\begin{abstract}
  In this document we describe the Poon-Domingos~\cite{poon-domingos} parameter learning algorithm
  for image classification and completion.
  \vspace*{-3.5em}
\end{abstract}

\maketitle

\section{Structure}

The Poon-Domingos algorithm uses a fixed structure and then learns the weights through generative
learning. We first give an overview on how to build the structure given an image and then provide a
pseudo-code algorithm for building such structure. In this document we assume instances as images.
However, the Poon-Domingos structure allows for any object with local dependencies.

\subsection{Overview}

The Poon-Domingos structure models a probability distribution over a set of variables with local
dependencies. On the plain, one could argue it models rectangular neighborhoods for each point in
the space. In the article~\cite{poon-domingos}, Poon and Domingos use images as a dataset, with
dependencies being rectangular pixel neighborhoods. Images are an example of local dependencies,
since a pixel has possible dependencies with their neighbors.

Dennis and Ventura explain an intuition of how the Poon-Domingos structure algorithm
works~\cite{clustering}. We expand on this intuition, giving insights on how such an algorithm is
built and showing a pseudo-code visualization of it. Once we have shown how to build the SPN
structure, we describe generative learning through gradient descent, and later
expectation-maximization.

\begin{figure}[h]
  \centering
  \includegraphics[scale=1.0]{imgs/dv_spn.png}
  \captionsetup{justification=raggedright}
  \caption{The Poon architecture with $r=1$ resolution and $k=1$ sum nodes per region on a
  2$\times$3 image. At each $r$ resolution axis-aligned rectangular decomposition, we create $k$
  sum nodes.\cite{clustering}\label{fig:dv_spn}}
\end{figure}

\subsection{Definitions and properties}

\begin{definition}[Region]
  A Region $\region{R}$ is a rectangular part of an image. Let $p_0=(x_0, y_0)$ and $p_1=(x_1,
  y_1)$ be the top-left and bottom-right pixels of $\region{R}$ relative to the image. These are
  called the coordinates of $\region{R}$.
\end{definition}

\begin{definition}[Region Node]
  A Region Node $R$ has a one-to-one and onto mapping with a Region $\region{R}$. $R$ has $k$
  internal nodes associated with it. If $\region{R}$ is over an $r\times r$ set of pixels (i.e.\
  the atomic unit), then $R$ has $k$ leaf nodes (e.g.\ $k$-mixture of gaussians). Else, $R$ has $k$
  sum nodes.
\end{definition}

\begin{definition}[Decomposition]
  Let $\region{R}$ be a Region. A Decomposition $\mathcal{D}$ is an axis-aligned partitioning of
  $\region{R}$ into two Regions $\region{R}_1$ and $\region{R}_2$.
\end{definition}

The decomposition $\mathcal{D}$ of a Region $\region{R}$ involves a few steps. Let $\region{R}_1$
and $\region{R}_2$ be the resulting subregions product of the decomposition. The resulting subgraph
of the SPN $S$ of this decomposition is a DAG $G$. If $\region{R}$ is the entire image, then the
root of $G$ is a single sum node and $G=S$. Otherwise, then the root of $G$ is a region node and
thus the root of $G$ is a set of $k$ sum nodes. Let $R$ be the root node of $G$. Region nodes $R_1$
and $R_2$ will both have $k$ sum nodes (or univariate distributions for leaves). We shall denote as
$R_i^j$ the $j$-th sum node of region node $i$. For each pairing of sum nodes $(R_1^i, R_2^j)$, we
create a product node $\pi$ and add $R_1^i$ and $R_2^j$ as children of $\pi$. The set $\Pi$ of
these product nodes are the decomposition nodes of $\region{R}$ into $\region{R_1}$ and
$\region{R_2}$.  Once we have created all product nodes in this set, we add all of them as children
of $R$. If $R$ is a region node, then adding $\Pi$ as children of $R$ means, for every sum node
$\sigma$ in $R$, set product node $\pi\in\Pi$ as a child of $\sigma$.

\begin{figure}[h]
  \centering\includegraphics[scale=0.4]{graphs/decomp.png}
  \caption{A decomposition of a Region $\region{R}$ into two subregions $\region{R}_1$ and
  $\region{R}_2$. The set $\Pi$ of product nodes are the decomposition nodes that connect the
  unsplit image to the partitions. Each element $\pi\in\Pi$ connects a pairing of a sum node of
  $\region{R}_1$ and of $\region{R}_2$.\label{fig:decomp}}
\end{figure}

Since a region node $R$ is unique, we may have different decompositions in which the same region
appears more than once. For this reason we should create a single Region Node for each possible
region. We need a map function that takes the top-left and bottom-right pixel positions of a region
and maps it to a number for storage. Since every region is unique, we need a one-to-one and onto
function.

\begin{definition}[Region map function]
  A region map function is a function that maps a region into an integer. We define it as
  \begin{align*}
    &f:\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n\to\mathbb{Z}_{m^2n^2}\\
    &f(x_1, y_1, x_2, y_2) = ((y_1m+x_1)m+x_2)n+y_2
  \end{align*}
  where $x_1,x_2\in\mathbb{Z}_m$ and $y_1,y_2\in\mathbb{Z}_n$.
\end{definition}

\begin{proposition}
  The region map function is one-to-one and onto.
\end{proposition}
\begin{proof}
  We first prove $f$ is one-to-one. If $f$ is injective, then $f(x_1,y_1,x_2,y_2) =
  f(x_1',y_1',x_2',y_2') \implies (x_1,y_1,x_2,y_2)=(x_1',y_1',x_2',y_2')$. Suppose
  $f(x_1,y_1,x_2,y_2)=f(x_1',y_1',x_2',y_2')$ for some $x_i\in\mathbb{Z}_m$ and
  $y_i\in\mathbb{Z}_n$. Then we have:
  \begin{align*}
    &((y_1m+x_1)m+x_2)n+y_2=((y_1'm+x_1')m+x_2')n+y_2'\\
    &(m^2y_1+mx_1+x_2)n+y_2=(m^2y_1'+mx_1'+x_2')n+y_2'\\
    &m^2ny_1+mnx_1+nx_2+y_2=m^2ny_1'+mnx_1'+nx_2'+y_2'\\
    &m^2n(y_1-y_1')+mn(x_1-x_1')+n(x_2-x_2')+(y_2-y_2')=0
  \end{align*}
  But $m,n>0$. Therefore, it is easy to see that $x_i-x_i'=0$ and $y_i-y_i'=0$ is necessary for the
  equation to hold. Proof of surjection is simple. Since we know $f$ is one-to-one and that
  $\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n$ has the same number of
  elements as $\mathbb{Z}_{m^2n^2}$, than it follows that $f$ must be onto.
\end{proof}

Bijection of the region map function is necessary since we need the inverse function $f^{-1}$ to be
symmetrical to $f$. That is, we must be able to encode a region into a number and later be able to
find what region a number represents. We define the inverse function of $f$ below.

\begin{definition}[Inverse region map function]
  The inverse of the region map function is given by the decomposition of an integer
  $r\in\mathbb{Z}_{m^2n^2}$ into a tuple $(x_1,y_1,x_2,y_2)\in\mathbb{Z}_m\times\mathbb{Z}_n\times
  \mathbb{Z}_m\mathbb{Z}_n$. Let $g=f^{-1}$. We define $g$ as an algorithm as follows
  \begin{algorithm}[H]
    \caption{\normalfont{Function \code{Encode}$\defeq f^{-1} = g$}}
    \begin{algorithmic}[1]
      \normalfont%
      \Require\,$r\in\mathbb{Z}_{m^2n^2}$
      \Ensure\,$(x_1,y_1,x_2,y_2)\in\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n$
      \State\,$y_2\gets i \mod n$
      \State\,Let $c\in\mathbb{Z}_{m^2n^2}$
      \State\,$c\gets\frac{(r-y_2)}{n}$
      \State\,$x_2\gets c \mod m$
      \State\,$c\gets\frac{c-x_2}{m}$
      \State\,$x_1\gets c \mod m$
      \State\,$y_1\gets\frac{c-x_1}{w}$
      \State\,\textbf{return} $(x_1,y_1,x_2,y_2)$
    \end{algorithmic}
  \end{algorithm}
\end{definition}

\subsection{Structural algorithm}

We now show how to construct the Poon-Domingos architecture given an image $I$ (which is equivalent
to a Region consisting of the entire image), resolution $r$ and $m$ sum nodes per region.

The algorithm, as summarized in the last subsection, can be constructed recursively. However we
avoid this technique in favor of an iterative version, which uses less memory. We must first do a
preprocessing of Regions. We iterate over all possible subrectangles in $I$, create a Region for
each of them and assign an identification number to it. This number is the value of the region map
function given the region's position. We name the region map function as \code{Encode} that takes a
region position and returns a non-negative integer. Similarly, we name the inverse function of
\code{Encode} as \code{Decode} that takes a non-negative integer and returns a region position.

We denote by $[\region{R}]$, where $\region{R}$ is a region, a function that returns a pair of
positive integers that represent the width and height of $\region{R}$. Once we have constructed all
possible regions, we iterate over all possible decompositions according to the following steps:

\begin{enumerate}[label=\arabic*.]
  \item\label{start-label} Select each possible region $\region{R}$ in image $I$
  \item If $\region{R} = I$, then $R$ is a sum node and is root
  \item Else if $R$ contains only gaussians, skip this region
  \item Else, $R$ exists and is a set of sum nodes
  \item Partition $\region{R}$ into a pairing of subregions $\region{R}_1$ and $\region{R}_2$
  \item For each subregion $\region{R}_i$
    \begin{enumerate}[label*=\arabic*]
      \item Let $(w, h) \gets \region{R}_i$
      \item If $w > r$ and $h > r$ then region node $R_i$ must be a set of $m$ gaussians
      \item Else, region node $R_i$ must be a set of $m$ sum nodes
    \end{enumerate}
  \item Create a set $\Pi$ of product nodes
  \item For each pair $(R_1^i, R_2^j)$, where $R_p^q$ is the inner node $q$ of subregion node $R_p$
    \begin{enumerate}[label*=\arabic*]
      \item Create a product node $\pi$ and add it to set $\Pi$
      \item Add $R_1^i$ and $R_2^j$ as children of $\pi$
      \item Add $\pi$ as child of all inner sum nodes of $R$
    \end{enumerate}
  \item Go to step~\ref{start-label}
\end{enumerate}

The structural algorithm is almost complete. The main object of interest now is on finding all
possible regions in an image. Consider the matrix $M_{n\times m}$ as the image representation of
$I$ indexed by 0. Then we can find all possible regions by iteration over every top-left position
$(x,y)$ and for each of these positions iterating over all bottom-right pixels $(x+p,y+q), 0\leq
p<n, 0\leq q<m$.

We assume a dataset $\mathcal{D}$ where each instance $\mathcal{D}[X]$ gives an ordered sequence of
integers corresponding to the image pixels in expanded form.

\begin{algorithm}[H]
  \caption{\code{CreateRegions}}\label{alg:createregions}
  \begin{algorithmic}[1]
    \Require\,A pair $(w,h)$ representing the image $I$ dimensions
    \Require\,Dataset $\mathcal{D}$
    \Require\,Integer $m$ as number of components in each Region
    \Require\,Integer $r$ as resolution
    \Ensure\,A list $\mathcal{L}$ of Regions indexed by their region map function value
    \State\,Let $n=w\cdot h$
    \For{$i\gets 0..(n-1)$}
      \State\,$x_1\gets i\mod w$
      \State\,$y_1\gets i/w$
      \For{$x_2\gets x_1..(w-1)$}
        \For{$y_2\gets y_2..(h-1)$}
          \State\,Let $R$ be a new Region node
          \If{$x_2-x_1 = r$ and $y_2-y_1 = r$}
            \State\,$R\gets$\mcode{GaussianMixture$(x_1, y_1, x_2, y_2, D, m)$}
            \LineComment{\code{GaussianMixture} returns a node containing $m$ gaussians}
          \Else%
            \State\,$R\gets$\mcode{RegionNode$(m)$}
            \LineComment{\code{RegionNode} returns a node containing $m$ sum nodes}
          \EndIf%
          \State\,$j\gets$\mcode{Encode$(x_1,y_1,x_2,y_2)$}
          \State\,$\mathcal{L}[j]\gets R$
        \EndFor%
      \EndFor%
    \EndFor%
    \State\,\textbf{return} $\mathcal{L}$
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{\code{Structure}}\label{alg:structure}
  \begin{algorithmic}[1]
    \Require\,A pair $(w,h)$ representing the image $I$ dimensions
    \Require\,Dataset $\mathcal{D}$
    \Require\,Integer $m$ as number of components in each Region
    \Require\,Integer $r$ as resolution
    \Ensure\,An SPN $S$ containing the learned structure from image $I$
    \State\,\mcode{CreateRegions$(w, h, D, m, r)$}
  \end{algorithmic}
\end{algorithm}

%--------------------------------------------------------------------------------------------------

\printbibliography[]

\end{document}
