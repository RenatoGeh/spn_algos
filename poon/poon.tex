\documentclass{amsart}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{thmtools,thm-restate}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage[backend=biber,url=true,doi=true,eprint=false,style=alphabetic]{biblatex}
\usepackage{enumitem}
\usepackage[justification=centering,singlelinecheck=false]{caption}
\usepackage{indentfirst}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage[x11names, rgb]{xcolor}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage{subcaption}
\usepackage{booktabs}
\usepackage{linegoal}
\usepackage{csquotes}
\usetikzlibrary{snakes,arrows,shapes}

\addbibresource{references.bib}

\makeatletter
\def\subsection{\@startsection{subsection}{3}%
  \z@{.5\linespacing\@plus.7\linespacing}{.1\linespacing}%
  {\normalfont}}
\makeatother

\makeatletter
\patchcmd{\@setauthors}{\MakeUppercase}{}{}{}
\makeatother

\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\Val}{\text{Val}}
\DeclareMathOperator*{\Ch}{\text{Ch}}
\DeclareMathOperator*{\Pa}{\text{Pa}}
\DeclareMathOperator*{\Sc}{\text{Sc}}
\newcommand{\ov}{\overline}
\newcommand{\region}{\mathcal}

\newcommand\defeq{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily def}}}{=}}}

\newcommand{\algorithmautorefname}{Algorithm}
\algrenewcommand\algorithmicrequire{\textbf{Input}}
\algrenewcommand\algorithmicensure{\textbf{Output}}
\algnewcommand{\LineComment}[1]{\State\,\(\triangleright\) #1}

\captionsetup[table]{labelsep=space}

\theoremstyle{plain}

\newcounter{dummy-def}\numberwithin{dummy-def}{section}
\newtheorem{definition}[dummy-def]{Definition}
\newcounter{dummy-thm}\numberwithin{dummy-thm}{section}
\newtheorem{theorem}[dummy-thm]{Theorem}
\newcounter{dummy-prop}\numberwithin{dummy-prop}{section}
\newtheorem{proposition}[dummy-prop]{Proposition}
\newcounter{dummy-corollary}\numberwithin{dummy-corollary}{section}
\newtheorem{corollary}[dummy-corollary]{Corollary}
\newcounter{dummy-lemma}\numberwithin{dummy-lemma}{section}
\newtheorem{lemma}[dummy-lemma]{Lemma}
\newcounter{dummy-ex}\numberwithin{dummy-ex}{section}
\newtheorem{exercise}[dummy-ex]{Exercise}
\newcounter{dummy-eg}\numberwithin{dummy-eg}{section}
\newtheorem{example}[dummy-eg]{Example}

\numberwithin{equation}{section}

\newcommand{\set}[1]{\mathbf{#1}}
\newcommand{\pr}{\mathbb{P}}
\newcommand{\eps}{\varepsilon}
\renewcommand{\implies}{\Rightarrow}

\newcommand{\bigo}{\mathcal{O}}

\setlength{\parskip}{1em}

\lstset{frameround=fttt,
	numbers=left,
	breaklines=true,
	keywordstyle=\bfseries,
	basicstyle=\ttfamily,
}

\newcommand{\code}[1]{\lstinline[mathescape=true]{#1}}
\newcommand{\mcode}[1]{\lstinline[mathescape]!#1!}
\newcommand{\dset}[1]{\mathcal{#1}}

\title{%
  \noindent\rule{13cm}{1.0pt}\\
  \vspace{0.2cm}
  The Poon-Domingos Parameter Learning Algorithm for Image Completion and Classification on
  Sum-Product Networks
  \noindent\rule{13cm}{0.8pt}
}
\xdef\shorttitle{The Poon-Domingos Algorithm}
\author[]{\normalsize\textbf{Renato Lui Geh}\\\small Computer Science\\Institute of Mathematics
  and Statistics\\University of SÃ£o Paulo\\\texttt{renatolg@ime.usp.br}}

\begin{document}

\begin{abstract}
  In this document we describe the Poon-Domingos~\cite{poon-domingos} parameter learning algorithm
  for image classification and completion.
  \vspace*{-3.5em}
\end{abstract}

\maketitle

\section{Structure}

The Poon-Domingos algorithm uses a fixed structure and then learns the weights through generative
learning. We first give an overview on how to build the structure given an image and then provide a
pseudo-code algorithm for building such structure. In this document we assume instances as images.
However, the Poon-Domingos structure allows for any object with local dependencies.

\subsection{Overview}

The Poon-Domingos structure models a probability distribution over a set of variables with local
dependencies. On the plain, one could argue it models rectangular neighborhoods for each point in
the space. In the article~\cite{poon-domingos}, Poon and Domingos use images as a dataset, with
dependencies being rectangular pixel neighborhoods. Images are an example of local dependencies,
since a pixel has possible dependencies with their neighbors.

Dennis and Ventura explain an intuition of how the Poon-Domingos structure algorithm
works~\cite{clustering}. We expand on this intuition, giving insights on how such an algorithm is
built and showing a pseudo-code visualization of it. Once we have shown how to build the SPN
structure, we describe generative learning through gradient descent, and later
expectation-maximization.

\begin{figure}[h]
  \centering
  \includegraphics[scale=1.0]{imgs/dv_spn.png}
  \captionsetup{justification=raggedright}
  \caption{The Poon architecture with $r=1$ resolution and $k=1$ sum nodes per region on a
  2$\times$3 image. At each $r$ resolution axis-aligned rectangular decomposition, we create $k$
  sum nodes.\cite{clustering}\label{fig:dv_spn}}
\end{figure}

\subsection{Definitions and properties}

\begin{definition}[Region]
  A Region $\region{R}$ is a rectangular part of an image. Let $p_0=(x_0, y_0)$ and $p_1=(x_1,
  y_1)$ be the top-left and bottom-right pixels of $\region{R}$ relative to the image. These are
  called the coordinates of $\region{R}$.
\end{definition}

\begin{definition}[Region Node]
  A Region Node $R$ has a one-to-one and onto mapping with a Region $\region{R}$. $R$ has $k$
  internal nodes associated with it. If $\region{R}$ is over an $r\times r$ set of pixels (i.e.\
  the atomic unit), then $R$ has $k$ leaf nodes (e.g.\ $k$-mixture of gaussians). Else, $R$ has $k$
  sum nodes.
\end{definition}

\begin{definition}[Decomposition]
  Let $\region{R}$ be a Region. A Decomposition $\mathcal{D}$ is an axis-aligned partitioning of
  $\region{R}$ into two Regions $\region{R}_1$ and $\region{R}_2$.
\end{definition}

The decomposition $\mathcal{D}$ of a Region $\region{R}$ involves a few steps. Let $\region{R}_1$
and $\region{R}_2$ be the resulting subregions product of the decomposition. The resulting subgraph
of the SPN $S$ of this decomposition is a DAG $G$. If $\region{R}$ is the entire image, then the
root of $G$ is a single sum node and $G=S$. Otherwise, then the root of $G$ is a region node and
thus the root of $G$ is a set of $k$ sum nodes. Let $R$ be the root node of $G$. Region nodes $R_1$
and $R_2$ will both have $k$ sum nodes (or univariate distributions for leaves). We shall denote as
$R_i^j$ the $j$-th sum node of region node $i$. For each pairing of sum nodes $(R_1^i, R_2^j)$, we
create a product node $\pi$ and add $R_1^i$ and $R_2^j$ as children of $\pi$. The set $\Pi$ of
these product nodes are the decomposition nodes of $\region{R}$ into $\region{R_1}$ and
$\region{R_2}$.  Once we have created all product nodes in this set, we add all of them as children
of $R$. If $R$ is a region node, then adding $\Pi$ as children of $R$ means, for every sum node
$\sigma$ in $R$, set product node $\pi\in\Pi$ as a child of $\sigma$.

\begin{figure}[h]
  \centering\includegraphics[scale=0.4]{graphs/decomp.png}
  \caption{A decomposition of a Region $\region{R}$ into two subregions $\region{R}_1$ and
  $\region{R}_2$. The set $\Pi$ of product nodes are the decomposition nodes that connect the
  unsplit image to the partitions. Each element $\pi\in\Pi$ connects a pairing of a sum node of
  $\region{R}_1$ and of $\region{R}_2$.\label{fig:decomp}}
\end{figure}

Since a region node $R$ is unique, we may have different decompositions in which the same region
appears more than once. For this reason we should create a single Region Node for each possible
region. We need a map function that takes the top-left and bottom-right pixel positions of a region
and maps it to a number for storage. Since every region is unique, we need a one-to-one and onto
function.

\begin{definition}[Region map function]
  A region map function is a function that maps a region into an integer. We define it as
  \begin{align*}
    &f:\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n\to\mathbb{Z}_{m^2n^2}\\
    &f(x_1, y_1, x_2, y_2) = ((y_1m+x_1)m+x_2)n+y_2
  \end{align*}
  where $x_1,x_2\in\mathbb{Z}_m$ and $y_1,y_2\in\mathbb{Z}_n$.
\end{definition}

\begin{proposition}
  The region map function is one-to-one and onto.
\end{proposition}
\begin{proof}
  We first prove $f$ is one-to-one. If $f$ is injective, then $f(x_1,y_1,x_2,y_2) =
  f(x_1',y_1',x_2',y_2') \implies (x_1,y_1,x_2,y_2)=(x_1',y_1',x_2',y_2')$. Suppose
  $f(x_1,y_1,x_2,y_2)=f(x_1',y_1',x_2',y_2')$ for some $x_i\in\mathbb{Z}_m$ and
  $y_i\in\mathbb{Z}_n$. Then we have:
  \begin{align*}
    &((y_1m+x_1)m+x_2)n+y_2=((y_1'm+x_1')m+x_2')n+y_2'\\
    &(m^2y_1+mx_1+x_2)n+y_2=(m^2y_1'+mx_1'+x_2')n+y_2'\\
    &m^2ny_1+mnx_1+nx_2+y_2=m^2ny_1'+mnx_1'+nx_2'+y_2'\\
    &m^2n(y_1-y_1')+mn(x_1-x_1')+n(x_2-x_2')+(y_2-y_2')=0
  \end{align*}
  But $m,n>0$. Therefore, it is easy to see that $x_i-x_i'=0$ and $y_i-y_i'=0$ is necessary for the
  equation to hold. Proof of surjection is simple. Since we know $f$ is one-to-one and that
  $\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n$ has the same number of
  elements as $\mathbb{Z}_{m^2n^2}$, than it follows that $f$ must be onto.
\end{proof}

Bijection of the region map function is necessary since we need the inverse function $f^{-1}$ to be
symmetrical to $f$. That is, we must be able to encode a region into a number and later be able to
find what region a number represents. We define the inverse function of $f$ below.

\begin{definition}[Inverse region map function]
  The inverse of the region map function is given by the decomposition of an integer
  $r\in\mathbb{Z}_{m^2n^2}$ into a tuple $(x_1,y_1,x_2,y_2)\in\mathbb{Z}_m\times\mathbb{Z}_n\times
  \mathbb{Z}_m\mathbb{Z}_n$. Let $g=f^{-1}$. We define $g$ as an algorithm as follows
  \begin{algorithm}[H]
    \caption{\normalfont{Function $g=f^{-1}$}}
    \begin{algorithmic}[1]
      \normalfont%
      \Require\,$r\in\mathbb{Z}_{m^2n^2}$
      \Ensure\,$(x_1,y_1,x_2,y_2)\in\mathbb{Z}_m\times\mathbb{Z}_n\times\mathbb{Z}_m\times\mathbb{Z}_n$
      \State\,$y_2\gets i \mod n$
      \State\,Let $c\in\mathbb{Z}_{m^2n^2}$
      \State\,$c\gets\frac{(r-y_2)}{n}$
      \State\,$x_2\gets c \mod m$
      \State\,$c\gets\frac{c-x_2}{m}$
      \State\,$x_1\gets c \mod m$
      \State\,$y_1\gets\frac{c-x_1}{w}$
      \State\,\textbf{return} $(x_1,y_1,x_2,y_2)$
    \end{algorithmic}
  \end{algorithm}
\end{definition}

%--------------------------------------------------------------------------------------------------

\printbibliography[]

\end{document}
